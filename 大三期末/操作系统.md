
# 计算机历史进程
## 脱机输入输出
 解决人机矛盾,cpu/io之间的速度不匹配问题
 事先把纸带装入机器,由外围及控制数据和程序输入到磁带上
 cpu需要这些数据和程序从磁带调入内存

 > [!NOTE]
 > 批处理: 把一组任务集中起来成为一个 ==批次==, 一次性交给计算机完成,无需人工调入

## 单道批处理系统
 ### 单道批处理系统
 对作业连续处理,把一批作业以脱机的方式载入到磁带上,在系统中配监督程序,控制作业有序的处理
 == 缺点==: 系统的资源得不到充分利用,每次io操作都会让cpu处于等待状态,IO操作的速度很低
   cpu利用率很低
### 多道批处理系统
 1. 资源利用率高, 能让多道程序交替运行,让cpu始终被占用,内存中多道程序可以提高内存利用率
 2. 系统吞吐量大, cpu和其他资源保持忙碌,仅当作业完成或运行不下去切换,系统开销小
 3. (缺点)平均周转时间长,排队处理,等待时间很长
 4. (缺点)无交互能力,用户无法和作业交互,修改和调试程序很困难
 
 ==问题==: 
   处理机争用问题, 内存分配和保持(每个程序都有自己独立的内存空间),io设备分配问题,
   文件组织和管理问题,作业管理问题,用户和系统的接口问题(用户无法交互)
   ==平均周转时间长==
### 分时系统 
  应对人机交互和共享主机的目的出现 
    一台主机上连接多显示器和终端形成的多用户系统
 ==多道系统中的作业驻留在外存内,等待载入内存后等待被运行的时间很长,期间用户无法和作业交互==

  1. 多路性 : 多路卡,周期性扫描多个终端
  2. 独立性 : 用户只能感知到自己,认为自己独占主机
  3. 及时性 : 把cpu时间划分为时间片,把时间篇为单位为终端用户服务
  4. 交互性
 ==问题==: 无法处理紧急的任务和及时处理任务(太公平.没有优先级)
### 实时系统
   可靠性

# OS 基本特性
## 并发
 系统允许运行多道程序
 > [!NOTE]
 > 并行是多个事件在同一时间内发生(建立在多核cpu),并发是同一时间间隔内发生
  
 为每个程序建立一个进程,可以被OS并发运行,增加系统吞吐量和资源利用率
## 异步
 程序不是一次性执行完的,而是在处理机上和多个程序交替执行

## 共享 
 系统的某些资源是可以被多个进程使用, io和硬盘等等

## 虚拟
 时分复用技术(把一个资源虚拟成多个资源,用时间来划分)
1. 虚拟处理机技术
2. 虚拟设备技术
 空分复用技术(用空间来划分)

# OS 结构
## 早期的无结构,关注效率和功能实现.内部复杂和凌乱
## 后来的模块化结构,按功能划分为多个独立模块.
 模块接口法,模块划分和规定模块之间的接口,模块划分应该平衡内外部复杂性
  > [!IMPORTANT]
  > 模块接口法,提高了OS设计的正确性,可适应性和加速OS开发的过程

  > [!CAUTION]
  > OS设计时的接口规定难以满足模块设计后的接口规定
  > 各个模块同时设计,无法找到合适的决定顺序,又称==无序化设计==

## 分层式结构OS,补充调用关系链,让无序的决定变成有序的 (由上一个层次的调用决定这个层次的设计,递归到宿主)
  1. 保证正确性
  2. 便于扩充和维护,(所有的设计都要满足调用关系,最后都要满足a0)
  
 但是系统效率低,各个层次单向依赖,调用功能要沿着调用链一层层穿越和通信

## 微内核OS ,精简核心功能==(和硬件紧密相关的部分)==,大部分功能都放入内核外面的服务器中
  客户-服务器模式
   > [!NOTE]
   > 进程服务器,终端,文件服务器,IO设备服务器
  涉及到用户态和内核态的切换
  面向对象,使用继承封装等概念确保正确性,可靠性,易修改性

   ==微内核的基本功能(机制)==:
  1. 进程管理
  2. 低级存储器管理
  3. 终端和陷入处理

  可扩展性,可移植性,可靠性,对分布式系统的支持,面向对象的技术

  运行效率有所降低,上下文切换
# 进程

## 程序的特征
  顺序性, 封闭性, 可再现性
## 定义
 为了能使程序并发执行,并对并发程序加以描述和控制
1. 进程是程序的一次执行
2. 进程是一个程序和它数据在处理机上顺序执行时所发生的活动
3. 进程是有独立功能的程序在一个数据集合上运算的过程,是系统调度和资源分配的单位

## 特征
 动态性,独立性,并发性,异步性

## 状态 
 就绪,执行,阻塞,(基本)||创建,终止

## 挂起激活
 进程可以被暂停挂起
 就绪状态可以被分为活动就绪和静止就绪,阻塞可分为活动阻塞和静止阻塞

1. 被挂起(暂停)的进程进入静止状态, 没被挂起的成为活动状态
2. 就绪进程可以被挂起-> 静止就绪 , 阻塞进程可以被挂起-> 静止阻塞
3. 没被激活就一直是静止状态, 静止阻塞可以被释放-> 静止就绪
4. 运行中的进程被挂起-> 静止就绪

创建状态可以直接-> 就绪 , 被挂起就是静止就绪,没被挂起就是活动就绪
执行完进程进入终止状态

![[Pasted image 20251208235440.png]]

## 进程管理的数据结构
对每个资源和进程都设置了一个数据结构,成为进程信息表
 包含描述,标识,指针,状态等
指针指向同类资源或者同类进程的信息表,或者是把不同资源分类连接成不同队列,方便调用

### 进程控制块PCB
 1. 作为独立运行基本单位的标志
 2. 存储线程上下文信息,实现间断式运行(cpu寄存器信息)
 3. 提供进程运行的全部信息
 4. 提供进程调度的所有信息
 5. 和其他进程的同步和通信

 ==包含==:
 进程标识符(内外部标识符)
 处理机上下文
 进程调度信息(状态,优先级,阻塞原因,进程调度信息)
 进程控制信息(程序和数据地址,进程同步和通信,资源清单,链接指针(下一个pcb的首地址))

### 组织方式:
1. 数目不多的用线性方式,把PCB组织在一个线性表中
2. 相同状态进程多的用链接方式,分成就绪队列,阻塞队列(根据阻塞原因再分队列),空闲队列,==通过PCB链接字链接成队列==
  按优先级从高到低排列就绪队列,按阻塞原因分类阻塞队列. 
  通过指针跳转访问(链表)
3. 把相同状态的进程 首地址放到一张索引表上,这些首地址存放在一块专用的内存单元上,各种队列指针根据地址找到PCB

## 进程控制 
 创建和终止进程,进程状态的切换. OS内部原语实现
 > [!IMPORTANT]
 > OS内核 支撑功能
 > 1. 中断处理 2. 时钟管理(记录进程执行了多久) 3. 原语操作
 > 资源管理功能
 > 1. 进程管理 2. 存储器管理  3. 设备管理


### 创建进程原语
  申请空白PCB-> 分配所需资源 -> 初始化PCB -> 插入就绪队列

 进程之间有家族关系,一个进程创建出一个进程就是创建一个子进程 
 ==导致进程创建进程的原因:==                                 ### 进程终止
  用户登录, 作业调度, 提供服务, 应用请求                     

###  终止进程
  正常结束,异常结束, 外界干预 ]
 
  检索PCB并读状态-> 正在执行的进程中止并置调度标志为true,被重新调度 -> 终止子孙进程,向父进程或系统归还资源->
  从队列移除
### 阻塞进程原语

 进程进入阻塞状态是为了被占用的共享资源或者新的数据操作和任务

 ==block :== 执行变阻塞-> 插入阻塞队列 -> 处理机重置cpu环境

 ==wake up==: PCB从阻塞队列移除-> PCB加入就绪队列


## 进程同步 
 ==互斥访问临界资源和等待进程运行结果==
 对临界资源应该被进程互斥访问,访问临界资源的代码片段叫做临界区(Critical Block)
 ==为了对临界资源是否被访问做出判定,加入进入区代码得到访问标志==

 ==等待的原则==: 空闲让进, 忙则等待, 有限等待, 让权等待

 方式: 关闭中断, 信号量
### 关中断,进程访问临界资源之前关闭中断,访问结束后开启中断

### 信号量
 表示资源的数量 
* 整型信号量
* 记录型信号量   ==加入等待队列,拒绝忙等,实现让权等待==

### 生产者消费者问题
 生产者拿到空位, 生产的时候拿到访问互斥锁mutex, 通过指针存放消费品,指针向后移动,释放mutex, 增加一个实位
 消费者拿到实位, 消费的时候拿到访问互斥锁mutex, 通过指针拿取消费品,指针向后移动,释放mutex, 增加一个空位
 > [!NOTE]
 > 可以用Swait And信号量,也可以使用管程条件变量  
 > Swait(s1,s2,s3) And信号量防止死锁,要么都可以请求到,要么都请求不到
### 读者写者问题 
 可以同时读,不可以同时写,也不可以同时读和写
 第一个读者 读进程数++ 读的时候获取wmutex,防止写操作发生, 后续的读操作可以只获取读锁就可以读取(进入区)
 读者读完后在册获取读锁,把读进程数-- ,最后一个读者释放Wmutex

 写着拿着写锁 ,读者进程要读取必须获得Wmutex, 读者进程拿不到Wmutex,会进入阻塞
 写者完成写操作释放Wmutex, 读者和写者可以竞争写锁 

==容易引起写者饥饿==

## 进程通信
 1. 共享存储器系统  (共享内存)
 2. 管道通信系统    (单向同步互斥)
 3. 消息传递系统  (直接间接)
 4. 客户服务器系统 (socket RPC)

## 虚拟内存空间
 每个进程都有自己的虚拟内存空间,高地址是内核空间,低地址是用户空间
 所有进程的内核空间被映射到一块固定的内存上,是共享的.
 用户空间每个进程独有
  
  1. 用户空间内的线程切换不涉及内核态切换(非主流)
  2. 现代操作系统线程内核感知,内核是调度实体. 线程阻塞或时间片用完都要被内核
    调度(入队和出队)
 
# 线程(调度的基本单位)
## 引入必要性
  进程创建要分配独立的资源,进程切换代价高(上下文切换)线程通过共享进程资源的方式提高并发性能,提高
  系统的吞吐量和资源利用率
  
## 内核级线程 用户级线程
 内核线程 被内核调度,阻塞后内核调度其他线程占用处理器,并且 很小的数据结构和堆栈,线程的切换快,开销小
   支持并行
 用户级线程 用户空间内的线程切换不涉及内核态切换,调度算法进程专有,
   但是涉及系统调用会阻塞(进入内核态),无法多线程并行
 
$$
w = 1/n 
$$

# 处理机调度
## 多层次调度
 * 高级调度,从后备队列中选取一个作业并创建进程, 外存->内存, 创建线程->就绪态
 * 中级调度,从挂起队列选取进程并把数据调回内存, 外存->内存, 挂起态->就绪态
 * 低级调度,从就绪队列选合适的进程分配处理机  , 内存-> CPU, 就绪态->运行态

## 作业调度算法
 > [!NOTE]
 > 作业是用户提交给系统的一项相对独立的工作
 作业通过IO设备输入到磁盘上,保存在一个后备队列里,由作业调度程序把它调入内存

 有作业控制块JCB, 作业有三个运行状态:后备(收容),运行,完成
 ==作业调度程序根据JBC检查资源是否满足需求,再根据算法选作业==
1. 先来先服务
2. 短作业优先
3. 优先级调度
4. 高响应比调度  ==(响应比-> ((响应时间- 到达时间)+ 服务时间 /  服务时间)==
   兼顾先来先服务和短作业优先
## 进程调度算法
* 非抢占式
 1. 先来先服务
 2. 短作业优先
* 抢占式
   1. 轮转法: 每过一段时间就中断.让调度程序调度队首进程.把处理机分配给它
   2. 优先级调度算法: 就绪队列中优先级最高的进程分配处理机
   > [!NOTE]
   > ==静态优先级==: 创建进程时决定0~255之间的整数,根据进程类型,对资源需求,用户要求决定
   > ==动态优先级==: 创建时被赋予优先级,随进程的进行和等待时间的增加改变 
   3. 多队列调度算法: 每种调度方法对应一个队列
   4. 多级反馈队列调度: 多个队列按照优先级排开,越往后时间片越长,优先级越低(进程队列长度),第一个队列是先来先服务调度
   5. 公平调度算法
   6. 实时调度算法 (抢占式和非抢占式)

# 死锁
 多个进程都互相拿着对方需要的资源并且要访问对方的资源
## 产生条件
1. 互斥条件
2. 请求和保持
3. 循环等待
4. 不可抢占
## 处理死锁
1. 预防死锁,代码会不会产生死锁
2. 避免死锁,资源动态分配的时候完成
3. 检测死锁,运行的过程中通过某些机制检测出来
4. 解除死锁
### 预防死锁
  可以从破坏产生条件入手
 * 请求和保持: 进程不能持有某些资源的时候请求其他资源
   1. 预先分配资源(第一种协议)
   2. 获得初期所需资源就运行,逐步释放资源(第二种协议)
 * 不可抢占: 保持了一些不可抢占资源的进程申请新的资源不被满足, 释放已经保持的所有资源(运行不下去,给其他进程让位)
     实现复杂,代价大 
     前段的运行结果失效
 * 循环等待: 资源要线性排列,从地位到高位可以连续申请,高位到地位必须释放高位再去申请低位
### 避免死锁
  在资源动态分配的时候.计算安全序列并按照它分配资源 
 ==银行家算法==:
   动态分配的一种策略,分为MAX,Allocation,Need, Available
   根据Available 在进程列表里寻找满足该进程 Need 的进程 
    然后该进程释放资源再重复寻找过程直到所有进程都执行完
 
  > [!NOTE]
  > 银行家算法预测系统安全性:
  > 在每个进程都短缺一个资源的情况下, 争夺剩下的资源,只要剩下的资源足够其中一个进程运行就不会有死锁
  > n(进程数) x (x-1 )每个进程所需的资源数的最大值 + 1 <= m 剩下的资源数


### 检测死锁
 死锁定理: 资源分配图里简化边后仍旧有边,说明进程运行因为请求资源而阻塞,进入死锁状态
       简化的过程就是把孤立的节点去掉的过程
### 解除死锁
 1. 终止进程,代价大
 2. 逐个终止进程 ,但是要选择合适的进程(算法),然后再次检测死锁

# 存储器管理
## 多层结构
 最高级: cpu寄存器 
 中间: 高速缓存,内存, 磁盘缓存
 低级: 磁盘,移动介质

## 用户程序执行流程
 1. 编译,形成若干个模块
 2. 解释,把模块和库链接在一起,形成装入模块
 3. 装入,由Loader 将模块装入内存

### 装入方式
 1. 绝对装入方式, 绝对的内存地址(编译器指定内存的固定起始位置,==适合单道批处理系统==)  ==因为起始位置时指定的.下一个作业来了刷新内存==
 2. 可重定位装入的方式(使用偏移量,只要直到在内存中实际的初始位置根据偏移量就能找到位置)
 > [!NOTE]
 > 静态: 直接改指令的地址 (不利内存碎片整理)
 > 动态: ==重定位寄存器内存放内存中的初始地址==,取出后加上偏移量
 3. 动态运行时装入 (因为涉及挂起,由内存数据挂到外存,再从外存到内存,物理地址必然改变).可被载入到任何位置
        但是程序运行时不允许再内存中移动位置
### 链接方式 
 1. 静态链接
 2. 装入时动态链接
 2. 运行时动态链接

## 连续分配存储管理器
 1. 单一连续分配, 用户程序独占整个用户空间
 2. 固定分区分配
 3. 动态分区分配 (空闲分区表,空闲分区链条)
     动态分区算法: 大而割,小而弃 

## 分页存储管理(有内部碎片/页内碎片)
 用户进程的地址是逻辑地址,每一个固定大小的数据单元叫做页, 对应内存中的一个物理块frame 
  
 逻辑地址(虚拟地址) 用页号和页偏移量表示: 页号P-> INT[逻辑地址A/页大小L] , 偏移量d -> A Mod  L  
### 页表
 OS为每个进程创建一个页表,保证页能映射到对应的内存地址
 
 cpu里有页表寄存器,存放页表在内存中初始地址和长度, 根据初始地址找内存中的物理帧frame
 再根据逻辑地址的偏移量计算实际物理地址,访问拿取数据

 这个过程两次访问内存(TLB 没命中): 找到页表+找到物理地址
### 快表
  把访问过的页表放到CPU内部的高速缓存区(TLB,其中一种)内,先检查TLB内有没有页表
  访问一次内存
### 多层页表结构
 原来是一大块页表,被拆分成多个页表
 逻辑地址三个部分: 外层页号(拿到页表),外层页内地址(拿到页),页内地址
 ==优缺点==: 
  * 交由多级管理,页表可以不连续了,避免所有页表都存放在一大块连续内存区域
  * 地址转换速度慢
  
## 分段存储(外部碎片(段和段之间的空隙))
 在分页存储中,某些功能代码散落在不同页上,调用功能的时候要在不同的页找代码
 解决: 用逻辑划分的方法划分出段,这个段是一个完整的空间
 ==好处==: 方便编程,高可读性 ; 信息共享可以在一块空间内完成,避免散落多个页; 信息保护以逻辑单位为基础,方便
 ==宗旨==: 存储更有逻辑 
 
逻辑地址: 段号(名) +段内地址
### 段表 
 类似页表,存放段和内存中逻辑段的地址

 cpu内也有段表寄存器,存放内存起始地址和段内长度

| 区分 | 页 | 段 |
| --------------- | --------------- | --------------- |
| 单位 | 物理 | 逻辑  |
| 大小 | 由系统决定 | 用户决定 |
| 地址维度 | 一维 | 二维 |

## 段页式存储
 地址: 段号 + 段内页号 + 页内地址

 cpu有段表寄存器,  段表大小 段报表始址  . 根据段表寄存器找到段内页表 , 从页表拿到页后 计算物理地址 


> [!NOTE]
> ==总结==: 
> 分页分段还是段页都要 把表存在内存上, 在寄存器中存放表的始址 和大小, 拿到内存中的页表,在页表里找到
>  对应的数据存在哪里, ==实际数据都存在内存里,cpu是找表的存放地址的==
> 没命中TLB 访问表,几级表访问几次内存 ,再加一次访问物理地址

## 虚拟存储器
  > [!NOTE]
  > 局部性原理: 
  > 较短时间内程序仅执行某一个部分,对应的存储空间也是一个部分

 在某一时间段内程序执行的部分区域在内存中就可以 , 用户感受到的内存比实际大

 ## 请求分页系统
  每个页表包含:
  页号  ,  物理块号,  状态位 ,  访问字段 ,   修改位  ,   外存地址
### 缺页中断
  指令执行期间找不到页,中断进程区外存中调入

#### 调入策略
  1. 调入时机
  * 预调入
  * 请求调入
  2. 调入位置
  * 足够对换空间: 从对换区调入
  * 不足对换空间: 不可修改的从文件区调入(因为不修改所以不用在文件区重写) ,可修改的放到对换区
  3. 调入方式
  要访问的页面不在内存, 向cpu发起缺页中断,保存现场,分析中断原因进入缺页中断程序 

#### 页面置换算法
   1. 最佳置换算法
   淘汰的都是以后永不使用的
   
   2. 先进先出页面置换 
    淘汰最先进入的页面
  3. LRU 置换算法(Least Rencently used)
  把最近最少使用的换出, 需要寄存器或栈来记录移位或弹出最久物理块栈底,压入新物理块
  4. LFU 置换算法
   内存里页面维护一个移位寄存器,记录访问频率

  5. Clock置换算法
   设置一个访问位,使用后标为1.把所有页面用指针链接成循环链表,顺时针遍历页面页面访问位,换出0的页面
   改进:加入修改位,修改后的文件重写入磁盘里,(使用位,修改位)访问的权重大于修改

## 请求分段存储管理  
  与 请求分页类似


# 输入输出
 
## 操作系统的资源转换技术
 1. 虚拟存储器(以cpu时间和外存空间换内存空间)(中断进程去换页)
 2. 缓冲技术  (以内存空间来换cpu和IO设备速度上的匹配)
 3. SPOOLing技术 (用外存空间代替独占设备,模拟出一些不存在的物理设备,解决独占设备资源不存在的问题)
    
## 磁盘的访问时间
 1. 寻道时间T(s) -> m * n(移动n条磁道所花费的时间之和)+s (启动磁臂的时间)
 2. 旋转延迟时间 T(r) -> 1/2r (r是转速)
 3. 传输时间 T(t) -> b(每次读写的字节数) / rN(N是一条磁道的字节数) 
 
## 磁盘调度算法
  目的: 让平均训导时间最短
  调度方法:
1. 先来先服务
2. 最短寻道时间优先 (有饥饿现象)
3. 扫描算法(电梯算法)
4. 循环扫面算法(单向扫描后要立即返回最大/最小磁道号位置)
 
