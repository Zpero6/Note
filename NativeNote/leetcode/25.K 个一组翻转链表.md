## 25.K 个一组翻转链表

思路 ： 反转链表 + 分组 反转 

方法：双指针（反转链表） 迭代法

**示例 1：**

<img src="https://cdn.jsdelivr.net/gh/icecreamstorm/Typora@master/img/202510231513405.jpeg" alt="img" style="zoom: 50%;" />



**示例 2：**

<img src="https://cdn.jsdelivr.net/gh/icecreamstorm/Typora@master/img/202510231512402.jpeg" alt="img" style="zoom:50%;" />

链表很长 ，需要分好多次反转。 就需要每次只反转一个链表 **， 为了防止把后面的链表丢失 ， 要 保存一个下一段链表的头节点** ， **把每一段给拼起来，就要有连接的部分 ， 把上一段的尾节点保存下来 。**

要把链表 看成是  1 -> 2 -> 3-> null    反转后就是    null <- 1 <- 2 <- 3 

 

创建虚拟节点 ，当作前驱节点prev

```java
ListNode dummy = new ListNode(0);
dummy.next = head;
ListNode prev = dummy;
```

创建头尾指针 ， 定位要反转的链表段，并保存下一链表的头节点 nextHead；

```java
ListNode end = prev;// 后驱节点
for (int i = 0; i < k; i++) {
    end = end.next;
    if (end == null) {
        return dummy.next;
    }
}
ListNode nextGroup = end.next;
ListNode start = prev.next;
```

反转链表 ， 把前驱节点指向尾节点

```java
end.next = null; // 打断链表进行分组排序
prev.next = reverseList(start);
start.next = nextGroup;
prev = start;

public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode curr = head;
    while (curr != null) {
        ListNode next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}
```

