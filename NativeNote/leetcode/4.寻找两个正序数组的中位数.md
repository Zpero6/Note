## [寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/description/)

方法：二分查找法

在数组中不断对半分，找合适的分割点

方法思路：

nums1 和nums2 两个数组，都是已经排好序的数组

只要把分割点找出来 ， 确保 nums1 分成两部分 a b  nums2分成两部分 c d

a和c被分到左侧， b和d被分到右侧

分隔点只要满足 a最大值 小于d最小值，c最大值小于b最小值即可



假设有一根绳子串联左侧所有元素， 那么左侧所有元素数量应该是确定的

绳子长度应该满足（如果总数是奇数，+1 /2正好是中间数的序数，正好包含中间的元素）

```java
int len = m+n+1/2
```



二分查找就是在数组中定位一半，看在那一半中



先把元素少的放在前面

```java
 if (nums1.length > nums2.length) {
            return findMedianSortedArrays(nums2, nums1);
        }
```

选取截取的左右两端，取nums1 的一半作为分割点 

```java
int left =0,right = m
int i = (left + right )/2;//左面有i个元素
int j = (m+n+1)/2 -i;//左面有j个元素
```



成立条件就是[i]-1 < [j] , [j-1]<[i]

//处理数组越界：当 i 或 j 为0时，只需要让 i-1 和 j-1 成最小值就行 或者让 j 和 i 成为最大值

```java
int maxLeft1 = (i == 0) ? Integer.MIN_VALUE : nums1[i - 1];
int maxLeft2 = (j == 0) ? Integer.MIN_VALUE : nums2[j - 1];

int minRight1 = (i == m) ? Integer.MAX_VALUE : nums1[i];
int minRight2 = (j == n) ? Integer.MAX_VALUE : nums2[j];
```

检查是否为分正确分割点

```java
if(maxLeft<minRight2 && maxLeft2< minRight1){
	if((m+n)%2 == 0){
        return （Math.max(maxleft1,maxleft2)+Math.min(minright1,minRight2))/2.0；
    }else{
        return Math.max(maxleft1,maxleft2);
    }
}
```

重新找分割点

1.如果是 [ i  - 1 ] > [ j ] , 就说明 i 应该在左边

2.如果是 [  j - 1 ] > [ i ] ， 说明 i 应该在右面

```java
else if (maxleft1 > minRight2){
    right = i-1;
}else{
    left = i + 1;
}
```



加入循环

```java
while(left <= right)
```

