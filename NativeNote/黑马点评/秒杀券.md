



## 秒杀券的使用

**1.数据库添加秒杀券**

**2.VoucherOrderController中添加秒杀功能 , 返回voucherOrder订单对象**

**3.利用mybatis-plus查询优惠券 , 返回优惠券对象**

**4.判断活动是否过期,优惠券库存是否为0,过期返回错误信息**

**5.更新数据库 , 库存减1**

**6.新建订单对象 , 把userId , voucherID, OrderID传入 , 返回订单对象**



### 全局ID生成



```java
    public long nextId(String keyPrefix) {
        //时间戳
        LocalDateTime now = LocalDateTime.now();
        long nowsecond = now.toEpochSecond(ZoneOffset.UTC);
        long timestamp = nowsecond - BEGIN_TIMESETUP;
        //序列号
        String date = now.format(DateTimeFormatter.ofPattern("yyyy:MM:dd"));
        Long count = stringRedisTemplate.opsForValue().increment("IDicr:" + keyPrefix + date);
        //连接返回

        return timestamp << COUNT_BITS | count;
    }

```



### 超买问题

多个线程并发秒杀 , 其中查询秒杀券库存 后才进行数据库库存扣除 ,  会导致超卖

**解决方案 :**  在数据库扣除过程中添加语句 

```java
seckillVoucherService.update().setSql("stock = stock-1").eq("voucherId",voucherId).gt("stock",0).update();
```

当**多个线程**查询数据库  stock为99 , 确认没过期和有库存后 , 进行数据库扣除 操作 , 添加where语句 , 防止stock小于0 还在扣除 .  



> **悲观锁和乐观锁**
>
> 悲观锁: 认为 线程安全问题一定发生 , 在操作数据时先添加锁 , 确保串行执行
>
> 乐观锁: 认为 线程安全问题不一定发生, 在更改数据时判断有没有线程对它做出修改



### 一人一单

代码没有规定 一个用户只能抢一单 , 所以 , 要在扣除库存之前 , 检验用户是否已经抢过

只需从数据库里查询 

```java
query().eq("userId" ,userid).eq("voucherId",voucherId).count()
```

看条目是否大于1即可判断是否多买

**问题: ** 仍然存在一个用户多买 的问题 , 原因是 , 查询和修改数据库不连贯 ,同一时间多个线程同时查询到 条目为0 , 		都有权去修改数据库 , 而且操作数据库 是由事务操作的 , 当事务没有提交 , 别的线程也用同一个用户id秒		杀 , 也会导致多买

**解决方案 :** 添加锁 , 不给抢券的过程添加锁, 这样会导致串行执行 , 降低效率 . **只需要让每个线程都是不同的用户,就		可以了 .**  **为用户的id上锁**

```java
synchronized(userId.toString().intern()){
	//由spring生成代理对象 ,jdk动态代理代理类型应该是 接口类
    IvoucehrOrderService proxy = (IVoucehrOrderService) AopContext.currentProxy();
    return proxy.createVoucherOrder(voucherId);
}

@Transactional
public Result createVoucherOrder(Long voucherId) {}
```



### jmeter测试  



## 集群下的并发问题

由于每个application 都会创建自己的tomcat服务器 , 都由自己维护的jvm. 而加锁的本质是在jvm中加入锁监视器,

用锁监视器来确保并发的安全问题

但是多个jvm会由多个锁监视器 , 锁并不共享  , **所以要添加一个公共锁**



**nginx配置负载均衡和方向代理**



**postman两个测试同时发起**

调试模式下测试同时发起, 两个服务器均收到请求 , 但是在模拟延迟的情况下 , 两个由相同userId的请求都通过 , 一个用户买了两单 , 出现错误



**解决方案**

​	自定义了一个SimpleRedisLock类 , 利用Redis的 `set key value nx ex[...]`来设置锁 

```java
boolean trylock(long timeout){
   Boolean success stringRedisTemplete.opsForValue()
        .setIfAbsent(key,value,timeout,TimeUnit.SECONDS);
    return Boolean.TRUE.equal(success);
}
void unLock(){
    stringRedisTemplete.delete(key);
}
```

​	设置有效期 , 并且合并expire语句和setnx语句,防止服务器在两个语句执行期间宕机

​	**在开始修改数据库创建订单前 加入公共锁** , 实现一人一单



### Redis分布式锁误删问题

<img src="https://cdn.jsdelivr.net/gh/icecreamstorm/Typora@master/img/202510041918976.png" alt="image-20250930000207791" style="zoom: 33%;" />
之前的 void unLock(){  stringRedisTemplete.delete(key);  }  可以简单删除key 

也就是说 , 只要知道key , 任何线程都有权去删除 . 而key的构成是 标准前缀+ userId , 会导致一人多单 . 

**需要给每一个key授予 删除权限 或标识** , 线程1只能删除线程1的,删不了别的线程

在删除时检验删除者是否是正确线程 , 不一致就不释放锁 , 实现并发安全

```java
private static final ID_PREFIX = UUID.randomUUID().toString();
//把线程标识加入value
boolean tryLock(long timeout){
    //...
    Boolean success = stringRedisTemplete.opsForValue().setIfAbsent(Key_Prefix+name , ID_PREFIX + Thread.currentThread().getId(),timeout,TimeUnit.SECONDS);
    return Boolean.TRUE.equal(success)
}

//释放锁加入标识验证
void unLock(){
    String id = ID_prefix + Thread.currentThread().getId();
    String value = stringRedisTemplete.opsForValue().get(key_prefix + name);
    if(id.equals(value)){
        stringRedisTemplete.delete(key_prefix + name);
    }
}
```

**但是这样还不够 , 因为验证标识和释放锁过程没有做到原子性**

在验证结束后 释放锁的过程中 , 如果线程1陷入阻塞 , Redis触发超时解除 , 锁被释放 . 此时另一个线程2获得锁 , 在刚才的线程1恢复后释放锁  , 会释放别的线程2的锁 , 还会导致误删的问题

**解决方案**  : 加入脚本 使操作原子化 . (Redis内部执行查询和删除时批处理的 , 一致性很强, 但是如果中途加入判断就		会解除原子性) 

​		

> Redis脚本 EVAL "Redis.call( 'Mset' , KEYS[1] , ARGV[1]  , KEYS[2] , ...) " keyNumber , KEYS[..] , ARGV[...]

```lua
if(Redis.call('get',KEYS[1]) == ARGV[1]) then
    return reids.call('del',KEYS[1]);
end
return 0
```

```java
//加入resouse/unLock.lua
//设置脚本的返回值和路径
private static final DefaultRedisScript<Long> unLockScript;
static{
    unLockScript = new DefaultRedisScript<>();
    unLockScript.setLocation(new ClassPathResource("unLock.lua"));
    unLockScript.setResultType(Long.class);
}
void unLock(){
    stringRedisTemplete.execute(unLockScript,Collections.singletonList(Key_prefix+name),ID_prefix + Thread.currentThread().getId());
}
```



> RedisScript<T> 是一个Redis脚本接口 ,  T为返回类型 , 实现类是 DefaultRedisScript<T>  . 执行脚本的execute方法 传入的参数是
>
> -  RedisScript<T> script
> - List<String> KEYS[]
> - Object  Value		



### Redis锁的问题

Redis分布式锁 归根结底还是 一次Redis 的 setnx 和 del 操作  ,  **基于的数据结构是Redis 的String 类型** , key保存为 用户id , 值为 服务器唯一标识(UUID)和线程id  . 

- 这样的锁只能 重入一次 ,只能上一次锁 ,  没有count 计数来提高重入性 . 

- 获取锁的时候用的是setIfAbsent , 只能获取一次 , 没有重试机制 . 
- 锁的超时释放时间是固定的 , 如果业务执行时间较长 , 存在安全隐患 , 引起并发问题
- 主从一致性



**解决方案:**    	 使用Redisson分布式锁

### Redisson分布式锁的原理

#### **1.tryLock阶段**  `(等待时间 , 超时释放时间 , 时间单位)`

- 获得当前的线程id , 时间  
- 获取锁需要进入tryAcquire 方法调用  tryAcquireAsync 方法 `<RFuture<Long>,waitTime , leaseTime , TimeUnit , threadId>` 异步操作
  - 判断是否传入leaseTime , 如果用户传入参数 , 就用定义的leaseTime . 如果没有 , 就用Redisson的看门狗默认值(30 秒)
  - 尝试异步获取锁 tryLockInnerAsync   , 执行lua脚本 , 如果成功返回nil , 失败返回 ttl. 
  - 执行结果返回 RFuture 对象
  - 返回 ttl `<Long>`
- 对ttl做判断 ,  是null 说明获取锁成功  ,直接返回 。 如果 ttl 有值 ，说明获取锁失败 ，需要重新获取
- 计算剩余等待时间为0 ，结束返回。 不为0 ，订阅释放锁的消息 ， 等待锁的释放直到剩余等待时间到清零为止 ， 超时处理取消订阅操作，清理已分配的资源
- 得到释放锁的消息 ，继续对剩余等待时间做判断 ， 然后再次尝试获取锁 ，成功结束 。 失败则订阅释放锁的消息 ，使用信号量getLatch（）的tryAcquire（timeout ，unit）实现超时等待 ， 直到ttl期限到达或剩余等待时间到期 。 
- 等待锁释放后 ，判断等待时间是否到期 。 到期获取失败 ， 没到期就继续获取所操作 ， 订阅消息 。。。

订阅消息要手动释放 ， 因此要在最后的两步 加入try finally 结束后自动释放。

- 获取锁成功后 ，自动更新expire  。开辟子线程添加任务  ，每隔1/3看门狗timeout就更新一次有效期， 使持有锁的时间是无限的。

**2.UnLock阶段**

- 进入 unLockAsync , 取消掉自动更新expire  ，调用UnlockInnerAsync 锁count -1。

### Redisson分布式锁的实现原理
- 可重入：利用hash结构，记录线程id和count，实现可重入
- 可重试：利用信号量机制pubsub机制实现等待，唤醒，获取锁失败的重试机制
- 超时续约：利用watchdog，每隔一段时间 ， 重置锁过期时间 （releaeTime/3）

### Redisson分布式联锁
解决主从不一致问题。在Redis集群中，主节点宕机并且主从没有同步，会导致数据的丢失。
设置多个可以读写的节点，同一个锁所有节点都持有，哪怕有一部分节点宕机，其他节点仍会持有锁，锁仍然是正常的。
#### **1.联锁阶段**
- 创建多个RedissonClient实例，并创建多个RLock对象
- 将RLock对象放入getMultiLock方法中创建联锁对象
#### **2.tryLock阶段**
- 根据是否重试（waitTime 是否为-1）是否设置锁持有时间（不会过期）来决定是否计算新的锁持有时间newLeaseTime，没设置就是-1；不可重试值为传入leasetime；可重试值为waitTime的两倍，防止获得锁后在其他的线程的等待时间内过期导致锁被抢用。
- 开辟一个List<RLock>装载获得的锁 。 使用ListIterator遍历传入的RLock对象
   - 如果不可重试且锁不会过期 ，只尝试获取一次锁 ， 调用空参tryLock（）
   - else，调用实参trylock
   - 如果锁获取成功，把获取的锁加入List
   - 不成功，List内全部解锁，在剩余等待时间内重新获取锁。。。。。。

### Redis分布式锁总结
- 不可重入的Redis锁，自定义依赖setnx 和ex命令，不可重入，无法重试，超时失效
- 可重入的Redis锁，利用hash结构实现可重入，用watchDog实现延续锁时间，用信号量控制重试等待
- multiLock，利用多个Redis实例实现读写分离，在所有节点都获取锁才算获取锁成功

------



## 基于异步实现秒杀优化

在tomcat中按找顺序执行查询优惠券、查询库存、校验一人一单、减库存、创建订单的顺序执行秒杀流程，一个线程的执行任务很多，处理的时间会拉长。

基于异步实现秒杀优化的思路是把查询和操作数据库分离，利用Redis的高度写性能做查询任务，提高系统的吞吐量

<img src="https://cdn.jsdelivr.net/gh/icecreamstorm/Typora@master/img/202510131714666.png" alt="image-20251013145713443" style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/icecreamstorm/Typora@master/img/202510131714908.png" alt="image-20251013171421680" style="zoom: 50%;" />

**利用lua脚本使操作Redis数据具备原子性**。因为要保存一些关键数据，保证每个元素都不会重复，因此**使用set数据类型**，存入用户id，优惠券id

 

------

假设在一段时间内有大量的用户去创建订单，通过Redis查验库存和重复下单情况生成订单对象传入阻塞队列中，由线程任务从队列中获取订单对象，完成数据库的减库存和建订单的过程，这是整个系统的流程。

### Redis操作部分

lua脚本：

```lua
-- 优惠券id ，用户id
local  voucherId = ARGV[1]
local  userId = ARGV[2]

-- 库存，订单编号
local stockKey = "seckill:stock:"..voucherId
local orderKey = "seckill:order:"..voucherId

--判断库存是否大于零
if(tonumber(Redis.call('get',stockKey)) <= 0) then
    --没有库存返回1
    return 1
end
--
--判断用户是否下单
if(Redis.call('sismember',orderKey,userId) == 1) then
   --下过单返回2
    return 2
end
--扣库存
Redis.call('incrby',stockKey,-1)
--下单
Redis.call('sadd',orderKey,userId)
return 0
```

脚本配置

```java
private static final DefaultRedisScript<Long> seckillScript;

static {
    seckillScript = new DefaultRedisScript<>();
    seckillScript.setLocation(new ClassPathResource("seckill.lua"));
    seckillScript.setResultType(Long.class);
}
```

没有库存返回1 ， 重复下单返回2 ，正常下单返回0

Redis中要保存一下几个数据：

- seckill:stock:voucherid 保存秒杀券的库存
- seckill:order:voucherid 保存某个秒杀券的订单

在创建秒杀券后 ， 向Redis中存入这两条数据，不设置过期时间



```java
@Override
public Result seckillVoucher(Long voucherId) {
    Long userId = UserHolder.getUser().getId();

    Long result = stringRedisTemplate.execute(
            seckillScript,
            Collections.emptyList(),
            voucherId.toString(), userId.toString()
    );

    int r = result.intValue();
    if (r != 0) {
        return Result.fail(r == 1 ? "库存不足" : "不能重复下单");
    }

    // TODO 保持阻塞队列
    VoucherOrder voucherOrder = new VoucherOrder();
    long orderId = RedisIDWorker.nextId("order");
    voucherOrder.setId(orderId);
    voucherOrder.setUserId(userId);
    voucherOrder.setVoucherId(voucherId);
    orderTasks.add(voucherOrder);
    proxy = (IVoucherOrderService) AopContext.currentProxy();
    return Result.ok(orderId);
}
```



在秒杀活动中存在这并发控制问题， 虽然Lua脚本确保了订单不会重复进入队列，但在异步处理订单时，仍需要操作数据库

数据库操作包括两个步骤：
检查用户是否已购买（query().eq("user_id", userId).eq("voucher_id", voucherId).count()）
创建订单并扣减库存（save(voucherOrder) 和 seckillVoucherService.update()）
这两个步骤之间仍存在时间窗口，可能导致并发问题



假设同一时间有两个用户请求几乎同时到达，我们称之为请求A和请求B，它们都是用户1的请求：
时间线分析：
T1时刻：请求A和请求B几乎同时进入系统
T2时刻：两个请求都执行Redis Lua脚本检查
Lua脚本原子性地检查用户1是否已下单
发现用户1尚未下单，将用户1加入订单集合
两个请求都通过了Lua脚本检查（因为Lua脚本执行非常快，两个请求几乎同时进行检查）
T3时刻：两个请求都被放入阻塞队列orderTasks中
T4时刻：异步处理线程从队列中取出请求A的订单进行处理
T5时刻：异步处理线程从队列中取出请求B的订单进行处理
这时候，虽然两个订单请求在Redis层面上都被认为是"第一次下单"，但实际上它们是同一个用户的重复请求。
数据库操作阶段的并发问题：
现在我们看看在处理这两个订单时数据库操作阶段会发生什么：
T6时刻：处理请求A时，执行数据库查询：

```JAVA
  Long count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
```

发现count=0（用户尚未购买

T7时刻：处理请求B时，同样执行数据库查询：

```JAVA
  Long count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
```

也发现count=0（因为请求A的订单尚未创建完成

T8时刻：两个请求都通过了用户购买检查，继续执行：

```java
save(voucherOrder);
```

**秒杀活动过程**

创建 voucherOrder对象，阻塞队列 BlockingQueue 

因为是异步操作，开辟线程去完成mysql的减库存和创建订单操作，要创建线程池和线程任务

线程池创建

```java
private static final ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor();
```

线程任务创建

```java
 @PostConstruct
    private void init() {
        SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler());
    }

    private IVoucherOrderService proxy;
private class VoucherOrderHandler implements Runnable {
    @Override
    public void run() {
        while (true) {
            //获取队列中的订单信息,take()方法会获取队列中的第一个元素，会进入阻塞状态等待直到元素可用
            try {
                VoucherOrder voucherOrder = orderTasks.take();
                handleVoucherOrder(voucherOrder);
            } catch (InterruptedException e) {
                log.error("处理订单异常");
            }
        }
    }

}
```

因为线程任务的目的是**开辟子线程，操作数据库减库存和sql创建voucherOrder**，而ThreadLocal又是线程隔离的

所以ThreadLocal的userHolder无法和子线程共享 ， AOP动态代理对象也无法在子线程中获得

要依靠voucherOrder对象中传入的userId 和  把AOP动态代理对象proxy设置为成员变量供handler使用 并于 主线程中给proxy赋值

在Redis
