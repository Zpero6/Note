## 为什么使用缓存?

缓存是高速读写缓冲区

缓存可以提高降低响应时间和后端开销 , 提升读写效率

缺点是 成本高 , 运行维护成本高 , 保持数据一致性成本高

## 黑马点评如何使用缓存?

使用Redis缓存减少客户端对数据库的访问次数 , 提高响应速度 至少300ms

访问数据时最先访问数据库 , 比如店铺信息 , 最先再Redis中查找key , 如果找到直接返回 .

找不到从数据库查找后返回给Redis保存 , 返回客户端店铺信息

```java
//代码逻辑
String jsonShop = stringRedisTemplete .opsForValue().get(key);
if(StrUtil.isNotBlank(jsonShop)){
    Shop shop = JsonUtil.toBean(jsonShop,Shop.class);
    return Result.ok(shop);
}
Shop shop = getById(id);
if(shop ==null){
    return Result.fail("msg");
}
stringRedisTemplete.opsForValue().set(key,JsonUtil.toJsonStr(shop));
return Result.ok(shop);
```

## 缓存使用策略

低一致性需求 有三种方式 , Redis自带的内存淘汰机制 , 超时剔除机制 , 和 主动更新机制

内存淘汰机制 , 等到内存超过2GB时 , 将淘汰不常用的键 , 这种方式有的键停留时间很长 , 数据一致性差, 但是维护成本无

超时剔除机制 , 加入ttl刷新键的时间  , 固定刷新的键会周期性的更新 , 下次查询时更新缓存 . 一致性比内存淘汰机制强 ,成本也不高

主动更新 需要再修改数据库的同时更新缓存 , 成本高

**最好使用内存淘汰机制**

高一致性需求需要维护数据一致性 , 要选择主动更新策略



## 缓存危机:

**缓存穿透**:

​	故意访问不存在的数据 , 让请求从Redis一直到达数据库 , 造成数据库压力增大宕机

​	解决方案: 设置返回空值 并赋ttl

​			bloom过滤器

**缓存击穿**

​	有一个高频访问的key突然失效 ,大量的请求访问数据库的同一个数据 , 加剧数据库的压力

​	解决方案: 添加互斥锁 , 确保只有一个线程可以访问数据库和更新缓存(因为要保护数据的一致性)

​			设置逻辑过期

**缓存雪崩**



## 缓存击穿互斥锁

当key过期导致未命中 , 去数据库里访问时获得锁 , 其他线程判断是否得到锁  , 得到的可以访问数据库 , 没有得到的休眠再次从Redis中 查找数据

1.获得互斥锁 

2.判断是否获得成功

3.失败 ,休眠重新查找Redis

4.成功 从数据库中读取数据并重建Redis

5.释放锁

- 一致性好
- 性能差
- 有死锁风险

## 缓存击穿逻辑过期

Redis设置永不过期的key , 但是添加逻辑过期字段 ,  是否过期用LocalDateTime.now().IsAfter()对比一下是否过期

如果过期就返回旧的对象 , 二次检查后开辟一个单独的线程去重建Redis缓存

- 一致性差
- 性能好
- 有额外内存消耗

## 缓存穿透方案

查找Redis的数据如果有返回  , 没有从数据库中查找并返回 . 如果都没有 , 就从往Redis中对应"key"的value设置为空, 以后查找都返回空,并设置ttl

布隆过滤: 设置拦截器 , 拦截不存在的key值



## 缓存雪崩方案

由于大量的key过期同时过期: 设置不同的ttl

由于Redis服务宕机: 建立Redis集群

添加限流降级策略

添加多级缓存

