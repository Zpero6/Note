
## JVM是什么？

	JVM是一个虚拟计算机 ，屏蔽底层操作系统差异， 让java程序 一次编写 到处运行

	同时可以管理内存 ， 处理异常 ， 执行字节码

- Oracal 官方发表的标准文档 ， 按照标准文档实现
- 在JDK包中包含
- 在运行中每个java进程都是JVM实例

读取并验证执行字节码 ， 解释为机器码和 编译热点字节码为本地机器码

**优点：**

 自动内存管理

 稳定的运行时环境 ：提供sandBox 环境，提供庞大标准库 ， 通过JNI可以调用c/cpp本地库。

 代码优化（即时编译器）：动态编译成本地机器码 ， 并深度优化

## JDK JRE JVM关系

**JRE： java运行时环境 ， 包含JVM 和核心类库。 用于运行已经编译的程序 .(class)**

**JDK： Java开发工具包 ， 有JRE和 开发工具（JavaC JDB（调试器）） 基础类库**

**JVM：虚拟机，将 .class 文件解释/编译成 机器指令。内存管理，GC机制**

‍

## JVM内存模型

‍

‍

## JVM内存碎片

JVM的 内存碎片 在堆内存分配和回收中产生 。 由于对象不连续分配和释放导致内存被切分为不连续的小块

内部碎片： 给对象分配但未被使用的部分

外部碎片：各个对象之间的内存块 ， 总量大但是分散。

**危害**

1. full GC 内存碎片无法分配给大对象 ， 触发Full GC --> 整合连续内存空间

2. OOM 内存溢出  堆空间Full GC 也没有拼凑出足够空间

3. 降低性能： 降低cpu缓存命中率

**减少碎片 ->垃圾回收器 ：**

 	使用 压缩 / 复制伏安法 。 在GC后 将存活的对象移动到一起，从另一端整理出一大段连续空间

1. Serial 收集器 ， 针对老年代：标记整理
2. Parallel Scavenge / Parallel Old ： 标记整理
3. G1 ： 标记整理 ， 但是 region 之间是 复制的
4. ZGC 和 Shenandoah 收集器： 并发标记和复制整理    低延迟短停顿

## 什么是方法区？在不同的JDK版本中方法区有何变化？

>  **主要回答 1.6和 1.7的区别 （永久代和元空间）**

	方法区主要存储  类信息/常量池（运行时常量池）/静态变量/JIT编译后的代码 ，是==线程共享的内存区域==

	**核心特点：**

1.  存储内容

2.  逻辑存储： 属于堆的逻辑部分，物理内存可以不连续

3. 内存可使用 固定大小 也可以 动态扩展

4.  和JDK版本相关

**JDK6 使用永久代设计**

	存储 类信息 ， 静态变量， 字符串常量池

**JDK7以后去永久化**

	字符串常量池和静态变量 放到堆中

**JDK8 彻底移除永久代 ， 改用元空间实现 ， 使用本地内存**

	元空间存储 类元数据 ， 运行时常量池

**变更原因：**

 	1. 永久代大小 受限于JVM ， 易引发OOM

		元空间使用操作系统的内存 ， 可以动态扩展

	2. 字符串常量池 放到堆中 ， 可以使用堆的GC 机制

	3. HotSpot 虚拟机 和其他JVM 实现统一

‍

‍

‍

‍

## JVM栈内存可能发生那些故障？

### <span data-type="text" style="background-color: var(--b3-font-background1);">可能发生的异常：</span>

1. stackOverflow

    线程请求栈的深度超出虚拟机允许的最大栈深度
2. OOM 内存溢出

    虚拟机栈和本地方法栈无法动态扩展，与线程创建时栈内存分配失败有关

### 避免方法

1. 优化递归逻辑

    确保递归有终止条件 或者改用迭代代替递归
2. 控制方法嵌套调用的深度

    减少方法嵌套层级
3. 调整JVM参数

    增大栈内存 -Xss256k ， 需要权衡资源
4.   代码审查和测试

    使用静态分析工具确定异常

    使用压测工具确定栈内存的合理值

  

‍

## 什么是直接内存？ 他和堆内存有什么区别？

 直接内存是 一种特殊的内存分配方式 ， 不由JVM直接管理 ， 而是通过java代码直接向操作系统申请的内存区域 。 这部分内存 在JVM堆外， 被称为“堆外内存” 通过Java NIO 的 ByteBUffer类 操作 ， 特别是通过 ByteBuffer.allocateDirect()方法分配 。 不属于JVM 堆的一部分 ， 但是显著提升数据传输效率, 减少 内存拷贝和GC压力

| 管理者  | JVM                | 直接向操作系统                    |
| ---- | ------------------ | -------------------------- |
| 特性   | 堆内存                | 直接内存                       |
| GC   | 受JVM垃圾回收器管理，GC会STW | 不受GC管理，GC不暂停               |
| IO   | 进行IO要额外内存拷贝        | 直接与操作系统数据传输                |
| 分配   | new 关键字 或者反射       | ByteBuffer.alloateDirect() |
| 回收   | JVM自动              | 手动释放 或Cleaner              |
| 内存限制 | 受限制与JVM启动参数        | 本机内存和OS寻址空间                |
| 安全性  | 相对安全 GC防止内存泄漏      | 有内存泄漏风险 ， 需要谨慎管理           |

### 如何管理？

1. 通过 ByteBuffer.allocateDirect()方法分配 ， 底层调用Unsafe allocateMemory  方法实现
2. 回收：

    需要手动释放 /  cleaner 机制回收

```java
public static void main（sdfsf）{
	ByteBuffer bu = ByteBUffer.allocateDirect(1024*1024);
	bu.putInt(123);
	bu.putDouble(12.22);
	//读取内存中数据
	bu.flip();
}
```

### 使用场景：

频繁和操作系统交互的场景

内存空间大的场景


## 调优JVM参数提高性能？常用调优参数？

**一 。 堆内存 配置**

- -Xms   -Xmx   设置初始和最大堆内存

  -Xms4g
- -Xmn 新生代大小 （堆的三分之一到四分之一）
- -XX ：NewRatio  新生代/老年代比例 （默认1：2）
- -XX ：Eden/Survivor （8：1：1）

**二。 垃圾回收器选择**

	G1 ： -XX:+UseG1GC  -XX:MaxGCPauseMillis=200  使用GC回收并平衡吞吐和延迟

	CMS： -XX:+UseConcMarkSweepGC  低延迟场景用并发清理回收

	并行回收器： -XX:+UseParallelGC 高吞吐场景

**三。 关键优化参数**

	元空间控制：-XX:MetaspaceSize = 256m  -XX:MaxMetaspaceSize =256m

	GC日志记录： -Xloggc:/path/gc.log  -XX:+PringGCDetalils

	OOM 自动转储 ： -XXX:+HeapDumpOnOutOfMemoryError  堆内存溢出转储成文件

	线程栈大小：-Xss256k

**四。 调优案例**

	电商系统优化：-Xmx12g -XX:+UseG1GC 把Full GC频率从每小时5次降到每天1次

	Tomcat调优： 调整-Xms120m  -Xmx120m 让Full GC 次数降低 80%

	内存泄漏处理： 弃用weakReference 优化缓存设计避免OOM

	（jstat/jmap）分析日志 ， 根据是cpu/io密集型判断 选择策略

‍ ‍

‍

‍

‍

‍

‍

## JVM如何处理异常？ try-catch-finally 结构字节码层面？

**JVM处理异常的步骤：**

1. 异常表机制：（方法级别）

    class字节码的一部分， 他为 try块 定义了异常处理器（catch）。他的每个条目包含四个信息： 起始位置，结束位置 ， 处理器位置（catch块的 字节码偏移量） ， 捕获异常的类型（该条目负责捕获的异常类型的常量池索引）

    - JVM 通过throw 关键字抛异常 ， 或检测到异常情况 ， 会创建异常对象。 立即停止当前方法的执行 并寻找异常处理器

    - JVM遍历异常表 ， 检查当前异常的指令位置是否在 起始位置和终止位置之间 ， 抛出的==异常类型是 捕获异常的类型条目==。执行 该条目指定的 处理器位置代码 ；

    - 异常表顺序敏感 ， 按照 catch块的书写顺序 生成异常条目 。 先捕获 Exception 再捕获 IoException 只会生效 Exception
    - 没在异常表中查到 异常处理器 ， JVM 就会弹出当前栈帧 ， 并回到上一个栈帧一场表中重复查找过程 ，直到找到合适的异常处理器
    - 如果一直没找到 ， 线程终止 ， 异常信息打印到控制台。

2. try catch finally 字节码处理

    finally会生成多份  ， 对应try块执行  /  try块抛异常  /  catch 完成后跳转   插入到这些路径后面 。

    ‍

## JVM类卸载？
### **为什么要类卸载？**

	为了节省内存 ， 尤其是业务需要动态加载和卸载大量类 的场景（tomcat 服务 ， 动态代理）不卸载就会一直占据元空间 导致OOM

	类卸载的条件：（无实例 ， 无Class 引用 ， 无ClassLoader引用）

1. 该类的所有实例都被回收
2. 改类的Class对象没被任何地方引用
3. 该类的类加载器已经被回收

#### 为什么 第三条很难实现？

ClassLoader  对 Classes 是 强引用 ， 内部维护一个 表记载所有它加载的InstanceKlass 对象的引用 。

Classes 对 CLassLoader 强引用 。

- 每个InstanceKlass 都有一个字段_class_loader指向ClassLoader。
- Class对象（mirror）也有一个getClassLoader（）的方法 。

**只要有一个类的实例还存活ClassLoader就死不了**

> 不可以被卸载的类:
>
> 	启动类加载器 加载的类
>
> 	扩展类加载器 加载的类
>
> 	存在静态变量/常量池引用的类
>
> 可以被卸载的类:
>
> 	自定义加载器加载的类
>
> 	动态生成并加载的临时类(动态代理,  反射)

### 打破引用，使其可被卸载？

 **使用自定义类加载器**

	例如： tomcat中 ， 一个web应用由 WebAppLoader加载 。应用卸载会销毁加载器实例 ， 不被GCRoots可达 ， 变成可回收垃圾 。

	当ClassLoader被回收后它的Class对象失去了一个强引用。

	无Class引用 ， 无实例 ， 这些Classes	就是可被卸载的

**观察类卸载：**

- ​**JDK 8 及以前**​：`-XX:+TraceClassLoading -XX:+TraceClassUnloading`
- ​**JDK 9 及以后 (Unified Logging)** ​：`-Xlog:class+load=info,class+unload=info`

- jconsole   jvisualVM

‍

‍

## JVM类加载？

经历五个步骤： 加载 ， 验证， 准备， 解析 ， 初始化

**加载**：

-  将.class 字节码载入到内存中, 并在元空间中创建InstanceKlass实例 （C++ 对象）, 将类的元信息存入 InstanceKlass （有_java_Mirror指针 ， 指向Class对象）。 InstanceKlass是JVM中的数据结构
 -  并在 运行时常量池中复制.class常量表的字面量、符号引用
-  在堆中创建镜像java\_lang\_Class::create\_mirror() ， 分配静态变量的占位  ，完成双向绑定

	**验证：**

- 校验 类的InstanceKlass数据的合法性
 
	**准备：**
 
- 为类的静态变量分配内存（jdk8+在堆中）和Class对象绑定 ， 并为静态字段设置默认值
 
	**解析：**
 
- 解析类的InstanceKlass 运行时常量池 ， 将符号引用换成直接引用
 
	**初始化：**
 
- 状态检查
- 执行 clinit 初始化
这是OOP - Klass 模型 ， HotSpot 虚拟机的对象实现

Class对象是一个InstacncKlass 的投影 ， 存储在堆中 ， 静态成员变量 生命周期和它绑定 ， 并存储在Class对象的尾部。（JDK8 设计）


##  clinit和 init 方法有什么区别？

都是java编译器在编译器自动生成 的特殊方法
分别对应类的初始化 和 对象的实例化

1. clinit 方法是类构造器方法
    包含所有静态变量的显式复制 和静态代码块的 代码
    **在类加载的时候** : 加载过程该类 ，执行该方法的时候完成类的初始化、
    
    每个类最多执行一次（多线程下加锁和同步）
    不用显示调用父类的clinit 方法 ， JVM 保证执行一个类之前 父类的Clinit已经执行完毕

2. init 方法是实例构造器方法
    在每次创建一个新对象的时候调用 ，可以被多次调用
    由 编译器根据 源码中的构造函数生成
    调用另一个重载的init 方法 ，或者父类的init （super（）） 方法
     构造函数没有显示写出就自己加上 super（） 
     不具备线程安全行

## 什么是逃逸分析？栈上分析和标量替换是什么
### 逃逸分析
JVm在编译阶段进行的高级优化
	分析对象的作用域或生命周期 ， 判断一个方法内部创建的对象是否被外部方法引用
 
 1. 方法逃逸： 一个对象在方法内部创建后 ， 作为返回值返回给了其他方法 ， 或者作为参数传递给了其他方法 
        它逃逸处理创建它的方法
 2. 线程逃逸： 一个对象赋值给了 一个可以在其他线程中访问的实例变量（静态变量） 或者被其他线程最直接访问，就是逃逸出创建它的线程
    
    如果一个对象没有发现任何逃逸，那么JVM可以对对象实施高效的优化 。（栈上分配和标量替换）

### 栈上分配
    不会发生方法逃逸就可以 不再heap 上分配内存 ，而是在线程栈上分配空间
  **为什么？**
    传统方式在heap上创建 被其他线程共享 ，对象的内存分配和GC 都会有开销 
  **优势**
    分配速度块 ，仅通过移动栈顶指针来完成
    自动销毁，随着栈弹出和方法结束自动销毁 , 不需要垃圾回收
    在栈上能更好的利用cpu缓存，因为和栈上的局部变量在一起
    
### 标量替换
    不会发生任何逃逸的对象 ， JVM编译时就不会真正创建完整的对象 ，而是把它拆解成他的成员变量
   **好处**：
     无需创建对象，也就避免分配内存空间 , 消除了对象头的内存开销
     标量可以被编译器进一步优化放入寄存器

## 程序计数器为什么是线程私有的？ 会OOM吗
  当前线程执行的字节码的行号指示器
  **功能**：
  1. 保证线程切换后能恢复到正确的执行位置
  2. 线程执行独立性：每个线程都应该有自己的 任务清单，各个线程互补干扰
  **会发生OOM吗**：
  不会， 程序计数器时 JAVA虚拟机规范唯一没有规定任何OOM的 区域
  1. 存储简单，所需空间小。仅存储下一条指令的内存地址
  2. 生命周期固定，无需动态扩容。
   线程创建时就会分配一个PC计数器， 分配时已经确定，无法改变内存大小
  3. 没有GC ，不引用对象
   不保存任何引用，只指向当前方法区的字节码指令，不被GC 管理。

## 字符串常量池和运行时常量池在JDK8中 在哪里存储?

  ### 字符串常量池
  专门存放字符串对象实例的缓存池 。 使用String.intern()就会返回常量池中实例的直接引用
  ### 运行时常量池
  在类加载的过程中把 类的“常量池表” 放入方法区的内容 。 包含各种字面量和符号引用
  |--- 类和几口的全限定名
  |
  |--- 字段的名称和描述符
  |
  |--- 方法的字段和描述符
  |
  |--- 字面量 (文本字符串，final常量)

> 字符串字面量在类加载时会被解析成 String对象 ，存储在字符串常量池中
> 运行时常量池的字符串符号引用 在解析阶段 指向字符串常量池中的真实对象引用


  ### JDK8 存储位置
  字符串常量池在 堆
  **好处**：
  1. 提高GC率 ，结束空间
  2. 减少永久代移除风险
  3. 性能提升,节省内存
  运行时常量池在元空间在=中
  **好处**：
  本地内存，无PermGen错误

## TLAB是什么， 解决什么问题？
  THread_Local_ALlocation_Buffer 线程本地分配缓存池
  位于Eden区 ， 线程创建是JVM 在Eden区分配的一块独立内存区
  线程创建对象首先尝试在TLab中床架
  ### 解决什么问题？
  多线程环境下堆的Eden区分【 内存时的锁竞争问题
  **痛点**：
  1. Eden区域线程共享 ，申请内存是线程要竞争锁，引发锁竞争，==并发瓶颈==
  2. 分配效率低： 每次分配都要同步过程，开销大

  **优势**：
  1. 消除锁竞争
  2. 提升分配速度： Tlab分配快速 ，简单移动指针快速分配
     新对象的内存  =  当前的TLAB 指针位置，TLAB指针 += 新指针大小
  3. 空间换时间： 为每一个线程预占一块大小默认为 Eden1% 的内存换来了巨大的性能提升
  **工作机制和细节**：
  1. 线程尝试在自己的TLAB中分配对象
  2. 如果TLAB的剩余空间足够， 分配成功，速度极快
  3. 如果剩余空间不足，线程像JVM 申请一个新的 TLAB （仍需要同步锁），然后在新的TLAB 里面分配对象 ，用尽的旧的TLAB 会等待垃圾回收

  **细节**：
    过大的对象无法放入TLAB，JVM尝试在Eden 区的共享地区进行分配，甚至可能直接晋升到老年代
     没有被利用空间的TLAB 可能因无法容纳新对象而浪费掉，为了性能做出的牺牲

  **TLAB JVM 参数**：
  -XX：+UserTLAB 启用TLAB (默认使用)
  -XX：+TLABSize  设置初始大小
  -XX：+ResizeTLAB  允许JVM在运行时自动调整TLAB大小
  -XX：+TLABReFillWasteFractionasteFraction：控制TLAB浪费比例，决定何时申请新的TLAB

## 如何实现一个自定义类加载器？
  继承java.lang.ClassLoader类并重写findClass（String name）即可
  
  **核心步骤**：
  1. 继承ClassLoader类
  2. 重写findClass类 。
    * 双亲委派模型： ClassLoader的LoadClass方法实现双亲委派模型
    先委托父加载器加载，父加载器无法加载的情况下调用自己的findClass
      不要重写loadClass ，而只需重写findClass即可
  3. 在findClass中完成类加载：
    * 读取类的全限定名 , 从自定义的位置读取类的字节码，并将其转换为字节数组byte【】
    * 调用defineClass方法，返回一个"Class<?>" 对象 </?>
    

  **双亲委派模型**：
  JAVA沙箱安全和类唯一行的基石
  保证了核心JAVA类总是被 BoostStrap加载器加载，避免用户冒充核心类
  
  如何保证双亲委派模型实现？
    尽量不要重写LoadClass 方法，因为该方法包含了双亲委派逻辑
  <Strong>同一个类被不同的类加载器加载后 JVM把他们看作是完全不同的类，互不兼容。会导致ClassCastException、LinkageError
  </Strong> , 每个类加载器都有自己的命名空间。（std::opstream 这里的opstream是std命名空间的 ，c++设计）
    
  **通过super （parent） 显示指定父类加载器 ，默认是APPClassLoader或SystemLoader**
  
  **权限控制**：
  自定义defineClass 是潜在安全风险点，因为可以动态定义任何类。
  从不信任的来源加载字节码 必须要严格安全检查和代码签名验证，防止恶意代码注入

## G1 垃圾回收器是什么？
  ### 设计
  将堆内存分化成不同区域(region) , 大小相等，由JVM自动调整。 
  每次回收回收整个region ， 对象存活就把对象移动到其他的区域。
  每个region对应一个 区域（Eden SurVivor Old  HUmongOus），空间可以不再连续
  可预测停顿模型： 设定最大预期停顿目标 。
        优先回收垃圾最多的region （garbege-First）；
        不会一次性回收整个老年代，每次Minor GC 或则 MixedGC 回收一部分老年代。控制cset大小 ，控制停顿时间
  ### 运行环节
  1. Yong Gen回收 : Eden 区满时触发，对Eden区GC
    STW 但是非常快 标记复制到SurVivor或Old Region（15岁）中（拷贝一次增加一岁）   
  2. Mixed GC : 老年代的占用率达到了-XX：InitiatingHeapOccupancyPercent指定的百分比
    回收新生代和部分老年代以及一些大对象

    
  | ---初始标记    STW 标记GC roots 可达对象，和YongGC同时
  |
  |---- 根区域扫描   扫描yonng Region 指向 old region 的==引用==
  | 
  | --- 并发标记  遍历整个堆，找出存活对象
  |
  | --- 重新标记   修正上一次标记的引用变化
  |
  | --- 并发回收  把有价值的region 放入cset （并发），把cset里面的存活对象 复制到新region中 ，清理旧region （STW） 

  3. FullGC 在Mixed过程中 ， 采用的复制算法，如果复制过程内存不够，触发FUllGC ，STW并采用单线程标记-整理算法 GC ，相当于一次SerialGC

## G1 垃圾回收器 的Mixed GC 何时触发？
  混合垃圾回收， 回收YOng gen 同时回收 一部分后台筛选出的老年代垃圾
  执行过程和 yong GC 过程完全一样 。  
  **MixedGC 本质** ：
    和Yong GC 过程差不多 ，把存活对象放到一个新的 region里面，并清除整个旧的Region
    但和YOng GC 相比，它会首先回收价值高的 老年代区。
    <Strong>完成了标记任务，只要发生yongGC，G1就会选取几个高回收价值的Old区进行回收</Strong>
    
   通常会多次连续MixedGC ， 直到G1将堆的占用率降低到一个目标值为止
  **MixedGC 的目标**：
  1. 最大限度回收内存，同时尽可能的满足最大预期停顿
       毕竟只选择回收价值高的目标回收，尽可能多的回收垃圾，清理出内存空间 
  2. 高效管理老年代，降低堆的占用率
        通过标记老年代的垃圾密度，有计划的清理老年代
  3. 完全避免FullGC的发生
        FullGC 是单线程的，会导致很长的STW。


## 四种引用类型的 的特点和应用场景？
  ### 强引用：
  **特点**：
    默认的引用类型，只要引用关系在就不会被回收掉。
  ### 软引用：
  **特点**：
    用来描述一些还有用但是非必须的对象, 内存不足时才会被GC回收
  **场景**：
    内存敏感的高速缓存，缓存内容可以在内存不足的情况下自动释放
    缓存使用软引用可以避免OOM , 并且提升i性能：内存充裕缓存可以一直存在 
  ### 弱引用 
  **特点**：
    比软引用更若，只能存活到下一次垃圾收集之前。只要发生GC就会被回收
    短时间使用频繁
  **应用场景**：
    规范化映射： WeakHashMap: 非常适合做缓存，保存非必须的元数据和辅助信息
    避免内存泄漏： 在某些监听器模式 可以用来保存监听器防止忘记注销内存泄漏
  ### 虚引用
  **特点**:
    无法用虚引用获取任何一个对象实例。在被垃圾回收器回收收到一个系统通知
  **场景**：
    跟踪对象被垃圾回收的活动，性能检测工具判断对象何时被回收、
    对象被回收后的后续一些清理工作，但是要和引用队列一起使用
 ### 如何用它来实现内存敏感的缓存？
  主要使用软引用 ，有时结合弱引用
  **步骤**：
  1. 定义缓存类： 使用HashMap 存储键和 软引用 的映射
  2. 引用队列： 当软引用引用的对象被GC 后 软引用加入引用队列 被及时的清理
  3. 提供put 和get 方法：get 中返回null 说明软引用引用的对象被GC，从队列中移除。
  4. 加入后台线程 定期清理引用队列，并把软引用从Map里移除

## 分配失败和晋升失败？触发GC？
  ### 分配失败：
  
  在Eden区 为对象分配内存但是Eden区内存不足 ，就是分配失败

  在高频创建对象的场景很常见

  **Yong GC触发**
  
  Eden和某个 s0区 中的存活对象要被迁移到 一个s1 区。如果s1 区内存也不足 ，或者对象的年龄超过设定，就会被分配到 Old区（也叫 晋升）

  ### 晋升失败：

  如果Yong GC 发生，Old 区没有足够的内存空间容纳 就会发生 晋升失败

  **Full GC触发**

  Full GC 和垃圾收集器有关。每个垃圾收集器的执行方式不同
    
  如果Full GC 之后老年代仍没有足够的内存容纳 ，就会抛出 OOM异常
 
 **严重情况**：
    内存泄漏
    Surivor 设置太小导致过早晋升
    新生代老年代比例不合适


## JVM 向量化API 
  
  **Vector APi**
    JAva提供的和平台无关的API，允许板鞋复杂的向量计算法。

  **核心作用**：
  1. 计算吞吐量极高：
        一条指令处理多条数据 ， 极大提高循环密集型的计算
  2. 可预测的高性能：
        传统JIT 自动向量化优化很脆弱 ， Vector API 明确表达并行意图，JVM可以稳定的生成高效向量指令， 提升可预测
  3. 表达清晰 简洁 ， 避免了JNI 的性能开销


