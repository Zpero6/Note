## 进程的状态
 运行状态, 就绪状态, 阻塞状态
 创建状态,结束状态

## 僵尸进程,孤儿进程
 僵尸进程已完成的进程处于终止状态,进程表里仍存在
 * 父进程没有调度wait()或waitpid(),OS里还保存的子进程的描述符

 孤儿进程,父进程关闭,子进程仍运行,会被init进程(id为1)收养,对他们状态收集.

## 进程调度算法
 1. 先来先服务
 2. 短作业优先
 3. 优先级调度
 4. 时间片轮转
 5. 最短剩余时间
 6. 多级反馈队列

 ### 1. 先来先服务
  先进先出,但是较短的进程等待时间较长,出现饥饿现象
 ### 2. 短作业优先
  减少平均等待时间和响应时间,难以准确预知进程的执行时间
 ### 3. 优先级调度
  抢占式的调度策略中,高优先级可以打断正执行的低优先级进程
 ### 4. 时间片轮转
  为每个进程分配固定的时间段运行,没运行完可以放回队列末尾.
  公平得到cpu时间,公平调度
 ### 5. 最短剩余时间优先
  抢占式的短作业优先调度改进版本,可打断进程,可以最小化平均等待时间
  执行时间难以预见
 ### 6. 多级反馈队列
 优先级调度 + 时间片轮转 ,分成多个就绪队列,每个时间片的大小不同,越小优先级越高
  既有短作业优先的效率,也有长作业延时的公平

## 进程间通信
 管道,信号,消息队列,共享内存,信号量,套接字
 
不同主机之间用 socket 通信,
同主机之间分进程类型
* unix 匿名管道,有名管道,信号 
* system V,POSIX 进程 消息队列,共享内存,信号量

### 匿名管道
 亲缘进程之间的通信方式,允许从内核中直接传递信息.(单向,先进先出)
### 命名管道
 无亲缘关系进程之间,通过操作系统的特殊文件传递信息.
 效率低,不适合频繁交换
### 信号
 通知接收进程某件事发生,signal
### 信号量 
 是一种锁操作,防止多个进程同时访问一个资源
 p操作减 wait,进程获得资源,执行P. 如果信号量大于0,减1.当进程的信号量为0的时候等待直到信号量大于0
 V操作加,signal . 进程释放资源的时候,信号量加1,唤醒等待资源的进程
### 消息队列
保存在内核中的消息链表,按照消息类型传递消息
长度有限制,存在用户态和内核态之间的数据拷贝

### 共享内存
 多个进程共享一个内存区域,直接写入这块内存,直接访问内存速度最快.
 但是容易出现多进程的数据错乱

## 线程的实现方式
1. 内核空间实现: 内核空间直接管理线程
2. 用户空间实现,内核空间感知不到
3. 混合实现, 用户态管理线程间的非阻塞时切换,内核空间管理线程间的阻塞时切换

## 线程间同步
 临界区:对共享资源访问的程序片段,只能有一个线程同时执行这个片段
 方式: 锁,互斥量
### 锁: 
 进入临界区的线程要执行加锁的操作,访问完成后释放锁
 分为自旋锁和无忙等待锁
 * 自旋锁: 在锁被其他线程持有的情况下,不断检查锁的状态直到锁可用,占用CPU资源==避免线程上下文切换==
 * 无忙等待锁: 锁被其他线程持有时等待,进入阻塞或休眠状态,让出cpu资源.锁释放被唤醒,==避免忙等待消耗cpu资源==

### 信号量
> [!NOTE]
> 表示资源的数量

## 死锁
> [!NOTE]
> 多个线程都互相拿着对方需要的资源并且要访问对方的资源

# 内存管理

## 物理内存和虚拟内存
 物理内存指的是计算机实际存在的硬件内存,计算机存储运行中的程序和资源的实际的内存资源
 虚拟内存是一种内存管理技术,让程序认为拥有连续独立的内存空间,实际上在物理内存和磁盘上
 ==虚拟内存是硬件和操作系统配合解决内存不足的方案,为每个进程提供连续独立的虚拟内存空间==
 * 虚拟内存适合用逻辑地址,要经过地址转换映射到物理内存中
 * 操作系统通过==页表==映射到物理内存,程序访问某个虚拟内存时cpu通过页表找到物理地址
 * OS把虚拟内存划分成若干个页,每个页被映射到物理内存的一个页中,物理内存不足时OS把不常用的页暂存到磁盘的交换分区

## 内存分段
程序由多个逻辑分段构成,(代码分段,数据分段,栈段,堆段),根据段的不同属性分出不同的段
分段机制下的虚拟内存由两个部分组成:段号,段内偏移量

## 内存分页 
 分页把整个虚拟内存和物理内存分成一段段固定尺寸的大小, 每个固定大小的连续内存空间是==页==
 每个页表保存虚拟页号和物理页表的映射
 > [!NOTE]
 > 数据访问要首先通过页表找到物理分页,加上页内偏移量获得真实的物理地址,然后访问物理地址拿到数据

### 多级页表
通过分层结构减少页表所需的内存开销
  > [!NOTE]
  > 单级页表每个条目占4字节,要用4M存储页表. 多级页表减少内存浪费
  > 对于32位虚拟地址,高10位存储一级页表索引,中10位存储二级页表索引 低12位存储业内偏移量
                   [图片](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-3021f22f-b9a3-49d9-9e80-6d3abaf5a61a.png)
### 快表
一段时间内程序的执行仅限于程序的某一部分,执行他们所访问的存储空间也在某个内存区域
把最长访问的页表放到访问速度更快的硬件上,在cpu设计了cache空间,被称为快表(页表缓存)

> [!IMPORTANT]
> 
> 分页和分段的区别
> * 段是逻辑单位,大小不固定,由它的功能决定,根据用户需要划分,对用户可见; 
>  页是物理单位,为了管理主存方便而划分,对用户不可见
> * 段向用户提供二位地址空间,页向用户提供一维空间地址
> * 段便于存储保护和信息共享,页的保护和共享受限制

## 交换空间
 OS把物理内存(RAM)分成一块块的小内存(页),内存不足时,OS把某些页的内容移到磁盘的一块空间
 物理内存和交换分区的总容量就是虚拟内存的可用容量

 ==用途==:
 * 程序启动时很多内存页用来初始化,之后不再需要后可以交换出去
 * 物理内存不够时,一些不常用的页就可以被交换出去,挪出空间

## 缺页中断
 程序访问的一个页不在物理内存中,就会发生缺页中断,OS 要从磁盘上的交换分区将缺失的页调入内存中
### 页置换算法
 最小化缺页中断的次数
 * ==最佳页面置换==,淘汰未来不会使用到的页
 * ==先进先出置换==,淘汰最近进入的页,新来的页加入队尾,移除队头
 * ==最近最久未使用置换==,LRU算法根据页面的访问历史来进行置换,但是会增加系统开销
 * ==时钟页面置换== , 循环链表遍历访问,标记使用位,页面被访问标记为1 . 页面要被置换时始终顺时针移动,找到使用位0的页
 * ==最不常用置换==, 根据页面被访问的频率置换,访问次数最少的先被置换


# 文件 

##  硬链接 软连接
 * 硬链接就是在目录下创建一个条目,记录文件名和inode编号
   inode 是源文件的inode .只要引用数量不为0就不会被删除
   ==不能跨越文件系统==

 * 软连接 重新创建一个文件,文件拥有独立inode,但这个文件是另外一个文件的路径
   ==可以跨文件系统==,就算目标文件被删除,连接还是存在

# IO

## 零拷贝
 减少上下文切换和内存拷贝次数

 传统IO 数据读取和写入是用户空间和内核空间的来回赋值,内核空间的数据来自于IO接口从磁盘的读取和写入
 期间发生多次用户态内核态切换和数据拷贝
 > [!NOTE]
 > read() 从用户->内核 读取数据在切换回来
 > write() 从用户->内核 写道socket 缓存区里再切换会去
 [拷贝过程](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-1e595664-6585-4d56-8939-08b7ce510218.png)
 实现: mmap + write  \ senfile

 * mmap()把内核缓冲区的数据==映射==到用户空间,内核和用户避免了数据拷贝
[拷贝过程](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-6dc49f9d-0bc3-4956-a650-7c7236f234a2.png)
 sendfile() 代替传统的read()和write(),从用户->内核,在内核态直接向socket缓冲区拷贝,省去两次上下文切换的开销
 > [!NOTE]
 > linux kernel 2.1中专门发送文件的系统调用函数

